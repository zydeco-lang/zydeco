data Tree (A : VType) where
  | +Fork(Tree A, Tree A)
  | +Final(A)
end

data Choice (B : CType) where
  | +L(U B)
  | +R(U B)
end

data Path (A : VType) where
  | +Nil()
  | +Cons(A, Path A)
end

def beep : Choice (U OS -> OS) =
  +L({ fn (k) ->
    ! write_line "0" k
  })
end
def boop : Choice (U OS -> OS) =
  +R({ fn (k) ->
    ! write_line "1" k
  })
end

def tree : Tree String =
  +Fork(+Fork(+Final("x"), +Final("o")), +Final("x"))
end
def path : Path (Choice (U OS -> OS)) =
  +Cons(beep, +Cons(boop, +Nil()))
end

def rec walk : Tree String -> Path (Choice (U OS -> OS)) -> OS = fn t p ->
  match t
  | +Final(res) -> (
    match p
    | +Nil() -> (
      ! write_line res {
        do correct <- ! str_eq res "o";
        match correct
        | +True() -> ! exit 0
        | +False() -> ! exit 1
        end
      }
    )
    | +Cons(_, _) -> ! exit 2
    end
  )
  | +Fork(tl, tr) -> (
    match p
    | +Nil() -> ! exit 3
    | +Cons(c, p') -> (
      match c
      | +L(k) -> ! k { ! walk tl p' }
      | +R(k) -> ! k { ! walk tr p' }
      end
    )
    end
  )
  end
end

main
  ! walk tree path
end
