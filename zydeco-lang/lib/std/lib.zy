/// the VType and CType kinds
pub extern def VType end
pub extern def CType end
/// the Thunk and Ret types
pub extern def Thunk (B : CType) : VType end
pub extern def Ret (A : VType) : CType end
pub alias U (B : CType) = Thunk B end
pub alias F (A : VType) = Ret A end

/// the primitive base types
pub extern def Unit : VType end
pub extern def Int : VType end
pub extern def Char : VType end
pub extern def String : VType end
pub extern def OS : CType end

// the interface for monads and algebras
pub extern codata Monad (M: VType -> CType) where
  | .return : forall (A: VType) .
    A -> M A
  | .bind : forall (A: VType) (A': VType) .
    Thunk (M A) -> Thunk (A -> M A') -> M A'
end
pub extern codata Algebra (M: VType -> CType) (R: CType) where
  | .bindA : forall (A: VType) .
    Thunk (M A) -> Thunk (A -> R) -> R
end

/// the identity functions

pub def id : Thunk(forall (A : VType) . A -> Ret A) = {
  fn A a -> ret a
} end

pub def id~ : Thunk(forall (B : CType) . Thunk B -> B) = {
  fn B b -> ! b
} end

/// the Top type
pub codata Top where
end

/// the Pair type

pub data Pair (A : VType) (A' : VType) where
  | +Cons : A * A'
end

pub def ! pair (A : VType) (A' : VType) (x : A) (y : A') : Ret (Pair A A') = 
  ret +Cons(x, y)
end

/// the Option type

pub data Option (A : VType) where
  | +None : Unit
  | +Some : A
end

/// the Either type

pub data Either (E : VType) (A : VType) where
  | +Left : E
  | +Right : A
end

/// the Bool type

pub data Bool where
  | +True : Unit
  | +False : Unit
end

pub def true : Bool = +True() end
pub def false : Bool = +False() end

pub def ! not (x: Bool) : Ret Bool =
  match x
  | +True() -> ret false
  | +False() -> ret true
  end
end

/* lazy not */
pub def ! not~ (t~: Thunk(Ret Bool)) : Ret(Bool) =
  do x <- ! t~;
  match x
  | +True() -> ret false
  | +False() -> ret true
  end
end

pub def ! and (x: Bool) (y: Bool) : Ret Bool =
    match x
    | +True() -> ret y
    | +False() -> ret false
    end
end

/* lazy, short-circuiting (left to right) and */
pub def ! and~ : Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool) = fn b1~ b2~ ->
  do b1 <- ! b1~;
  match b1
  | +True() -> ! b2~
  | +False() -> ret false
  end
end

pub def ! or : Bool -> Bool -> Ret(Bool) = fn x y ->
  match x
  | +True() -> ret true
  | +False() -> ret y
  end
end

/* lazy, short-circuiting (left to right) or */
pub def ! or~ : Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool) = fn b1~ b2~ ->
  do b1 <- ! b1~;
  match b1
  | +True() -> ret true
  | +False() -> ! b2~
  end
end

pub def ! nand : Bool -> Bool -> Ret(Bool) = fn x y ->
  do a <- ! and x y;
  ! not a
end

pub def ! nor : Bool -> Bool -> Ret(Bool) = fn x y ->
  do a <- ! or x y;
  ! not a
end

pub def bool_eq : Thunk(Bool -> Bool -> Ret(Bool)) = {
  fn b b' ->
    match b
    | +True() -> ret b'
    | +False() -> ! not b'
    end
} end

pub def if : Thunk(forall (B : CType) . Bool -> Thunk B -> Thunk B -> B) = {
  fn B b thn els ->
    match b
    | +True()  -> ! thn
    | +False() -> ! els
    end
} end

pub def if~ : Thunk(forall (B : CType) . Thunk(Ret Bool) -> Thunk B -> Thunk B -> B) = {
  fn B b thn els ->
    do b <- ! b;
    ! if B b thn els
} end

/// the Nat type

pub data Nat where
  | +Z : Unit
  | +S : Nat
end

pub def rec ! iter (A : VType) (n : Nat) (x : A) (f : U (A -> F A)) : F A =
  match n
  | +Z() -> ret x
  | +S(n') ->
    do x' <- ! iter A n' x f;
    ! f x'
  end
end








alias fo = forall (A : VType) (B : VType) . A -> B -> F (A * B) end
def ! foo : fo =
  fn A B a b -> ret +Cons(a, b)
end

def ! _ (C: VType) (c: C) =
  ! foo C C c c
end

def ! _ (B: VType): _ =
  ! foo B B
end


pub extern def write_str : Thunk(String -> Thunk(OS) -> OS) end
pub extern def read_line : Thunk(Thunk(String -> OS) -> OS) end
pub extern def read_line_as_int : Thunk(Thunk(Option Int -> OS) -> OS) end
pub extern def read_till_eof : Thunk(Thunk(String -> OS) -> OS) end
// pub extern def arg_list : Thunk(Thunk(List String -> OS) -> OS) end
pub extern def random_int : Thunk(Thunk(Int -> OS) -> OS) end
pub extern def exit : Thunk(Int -> OS) end


main
  with IO
    import exit = exit
  begin
    ! exit 0
  end
end



codata IO (A: VType) where
  | .run : Thunk (A -> OS) -> OS
end

// Algebra IO OS exists
def ! alg_io : Algebra IO OS =
  comatch
  | .bindA A m k -> ! m .run k
  end
end

// Algebra Ret R always exists
def ! alg_ret (R: CType): Algebra Ret R =
  comatch
  | .bindA A m k ->
    do a <- ! m; ! k a
  end
end

// Algebra M (M V) always exists for M: Monad
def ! alg_mo
  (M: VType -> CType)
  (V: VType)
  (mo: Thunk (Monad M))
: Algebra M (M V) =
  comatch
  | .bindA A m k ->
    ! mo .bind A V m k
  end
end
