# zydeco std


module Builtin where
  ## the Thunk and Ret types

  pub extern data Thunk (B : CType) end
  pub extern codata Ret (A : VType) end
  pub alias Comp (B : CType) = Thunk B end
  pub alias U (B : CType) = Thunk B end
  pub alias F (A : VType) = Ret A end

  ## the Fn type

  pub codata Fn (A: VType) (B: CType) where
    | .arg(A) : B
  end
  ### Functions are syntax sugars around this internal type definition.
end


module Std where
  ## identities

  pub def id : Thunk(forall (A : VType) . A -> Ret A) = {
    fn A x -> ret x
  } end

  pub def id~ : Thunk(forall (B : CType) . Thunk B -> B) = {
    fn B x -> ! x
  } end

  pub data Unit where
    | Unit()
  end

  module Prod where
    pub data Pair (A : VType) (A' : VType) where
      | Cons(A, A')
    end

    pub def fn pair (A : VType) (A' : VType) (x : A) (y : A') : F(Pair A A') = 
      ret Cons(x, y)
    end
  end

  ## the Option type

  pub data Option (A : VType) where
    | None()
    | Some(A)
  end

  module Bool where
    pub data Bool where
      | True()
      | False()
    end

    pub def true : Bool = True() end
    pub def false : Bool = False() end

    pub def not : Thunk(Bool -> Ret(Bool)) = {
      fn (x) ->
        match x
        | True() -> ret false
        | False() -> ret true
        end
    } end

    # lazy not
    pub def not~ : Thunk(Thunk(Ret(Bool)) -> Ret(Bool)) = {
      fn t~ ->
        do x <- ! t~;
        match x
        | True() -> ret false
        | False() -> ret true
        end
    } end

    pub def and : Thunk(Bool -> Bool -> Ret(Bool)) = {
      fn x y ->
        match x
        | True() -> ret y
        | False() -> ret false
        end
    } end

    # Lazy, short-circuiting (left to right) and
    pub def and~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
      fn b1~ b2~ ->
      do b1 <- ! b1~;
      match b1
      | True() -> ! b2~
      | False() -> ret false
      end
    } end

    pub def or : Thunk(Bool -> Bool -> Ret(Bool)) = {
      fn x y ->
        match x
        | True() -> ret true
        | False() -> ret y
        end
    } end

    # Lazy, short-circuiting (left to right) or
    pub def or~ : Thunk(Thunk(Ret(Bool)) -> Thunk(Ret(Bool)) -> Ret(Bool)) = {
      fn b1~ b2~ ->
      do b1 <- ! b1~;
      match b1
      | True() -> ret true
      | False() -> ! b2~
      end
    } end

    pub def nand : Thunk(Bool -> Bool -> Ret(Bool)) = {
      fn x y ->
        do a <- ! and x y;
        ! not a
    } end

    pub def nor : Thunk(Bool -> Bool -> Ret(Bool)) = {
      fn x y ->
        do a <- ! or x y;
        ! not a
    } end

    pub def bool_eq : Thunk(Bool -> Bool -> Ret(Bool)) = {
      fn b b' ->
        match b
        | True() -> ret b'
        | False() -> ! not b'
        end
    } end

    pub def if : Thunk(forall (B : CType) . Bool -> Thunk B -> Thunk B -> B) = {
      fn B b thn els ->
        match b
        | True()  -> ! thn
        | False() -> ! els
        end
    } end
    pub def ifc : Thunk(forall (B : CType) . Thunk(Ret Bool) -> Thunk B -> Thunk B -> B) = {
      fn B b thn els ->
        do b <- ! b;
        ! if @(B) b thn els
    } end
  end

  module Nat where
    pub data Nat where
      | Z()
      | S(Nat)
    end

    pub def rec fn iter (A : VType) (n : Nat) (x : A) (f : U (A -> F A)) : F A =
      match n
      | Z() -> ret x
      | S(n') ->
        do x' <- ! iter @(A) n' x f;
        ! f x'
      end
    end
  end

  module List where
    pub data List (A : VType) where
      | Nil()
      | Cons(A, List A)
    end

    pub def rec foldl : forall (A : VType) (R : VType) . List A -> Thunk(A -> R -> Ret R) -> R -> Ret R =
      fn A R l step s ->
        match l
        | Nil() -> ret s
        | Cons(x, xs) ->
          do s' <- ! step x s;
          ! foldl @(A) @(R) xs step s'
        end
    end
  end

  module LList where
    pub data LListV (A : VType) (B : CType) where
      | Nil()
      | Cons(A, Thunk(B))
    end

    pub codata LList (A : VType) where
      | .run(): Ret (LListV A (LList A))
    end

    pub def rec fn foldr (A : VType) (B : CType) (xs : U (LList A)) (b : U B) (f : U(A -> U B -> B)) : B =
      do xsv <- ! xs .run();
      match xsv
      | Nil() -> ! b
      | Cons(hd, tl) -> ! f hd {! foldr @(A) @(B) tl b f}
      end
    end

    pub def fn nil (A : VType) : LList A =
      comatch | .run() -> ret Nil() end
    end

    pub def rec fn forever (A : VType) (x : A) : LList A =
      comatch
      | .run() -> ret Cons(x, { ! forever @(A) x })
      end
    end

    pub def fn head (A : VType) (xs : U(LList A)) : F(Option A) =
      do xs' <- ! xs .run();
      match xs'
      | Nil() -> ret None()
      | Cons(x, tl) -> ret Some(x)
      end
    end

    pub def fn cons (A : VType) (hd : A) (tl : U (LList A)) : LList A =
      comatch 
      | .run() -> ret Cons(hd, tl)
      end
    end

    pub def fn append (A : VType) (xs : U(LList A)) (ys : U(LList A)) : LList A =
      ! foldr @(A) @(LList A) xs ys {fn x b -> ! cons @(A) x b}
    end

    pub def rec fn bind (A : VType) (A' : VType) (xs : U(LList A)) (f : U(A -> LList A')) : LList A' =
      ! foldr @(A) @(LList A') xs {! nil @(A')} {fn x b -> ! append @(A') {! f x} b}
    end

    pub def fn squash (A : VType) (xs : U(LList (U(LList A)))) : LList A =
      ! bind @(U(LList A)) @(A) xs {fn x -> ! x}
    end

    pub def fn map2 (A : VType) (A' : VType) (R : VType) (f : U(A -> A' -> F(R))) (xs : U(LList A)) (ys : U(LList A')) : LList R =
      ! foldr @(A) @(LList R) xs {! nil @(R)} {
        fn x acc ->
         ! foldr @(A') @(LList R) ys acc {
          fn y acc' ->
            do r <- ! f x y;
            ! cons @(R) r acc'
         }
      }
    end

    pub def fn cart_prod (A : VType) (A' : VType) (xs : U(LList A)) (ys : U(LList A')) : LList (Prod.Pair A A') =
      ! map2 @(A) @(A') @(Prod.Pair A A') {! Prod.pair @(A) @(A')} xs ys
    end
  end

  module Arith where
    ### we support the constructors externally because
    ### the parsers of their constructors are customized
    ### so the type is registered as a data type but the constructors
    ### are not implemented as internal constructors
    pub extern data Int end

    pub extern def add : Thunk(Int -> Int -> Ret Int) end
    pub extern def sub : Thunk(Int -> Int -> Ret Int) end
    pub extern def mul : Thunk(Int -> Int -> Ret Int) end
    pub extern def div : Thunk(Int -> Int -> Ret Int) end
    pub extern def mod : Thunk(Int -> Int -> Ret Int) end

    pub extern def int_eq : Thunk(Int -> Int -> Ret Bool) end
    pub extern def int_lt : Thunk(Int -> Int -> Ret Bool) end
    pub extern def int_gt : Thunk(Int -> Int -> Ret Bool) end
  end

  module String where
    pub extern data Char end
    pub extern data String end
    ### we support the constructors externally

    pub extern def str_length : Thunk(String -> Ret Int) end
    pub extern def str_append : Thunk(String -> String -> Ret String) end
    pub extern def str_eq : Thunk(String -> String -> Ret Bool) end
    pub extern def str_index : Thunk(String -> Int -> Ret Char) end

    pub def char_eq: Thunk(Char -> Char -> Ret Bool) = {
      fn (c: Char) (c': Char) ->
        do c <- ! char_to_str c;
        do c' <- ! char_to_str c';
        ! str_eq c c'
    } end

    ## conversions

    pub def unit_to_str : Thunk(Unit -> Ret String) = {
      fn (_u : Unit) -> ret "()"
    } end
    pub def bool_to_str : Thunk(Bool -> Ret String) = {
      fn (b : Bool) ->
        match b
        | True() -> ret "True"
        | False() -> ret "False"
        end
    } end

    pub extern def int_to_str : Thunk(Int -> Ret String) end
    pub extern def char_to_str : Thunk(Char -> Ret String) end
    pub extern def char_to_int : Thunk(Char -> Ret Int) end
    pub extern def str_to_int : Thunk(String -> Ret Int) end
  end

  module OS where
    pub extern codata OS end
    pub extern def write_str : Thunk(String -> Thunk(OS) -> OS) end
    pub extern def read_line : Thunk(Thunk(String -> OS) -> OS) end
    pub extern def exit : Thunk(Int -> OS) end
    pub extern def arg_list : Thunk(Thunk(List String -> OS) -> OS) end

    pub def write_line : Thunk(String -> Thunk(OS) -> OS) = {
      fn (s: String) (k: Thunk(OS)) ->
        do s <- ! str_append s "\n";
        ! write_str s k
    } end

    pub def write_int : Thunk(Int -> Thunk(OS) -> OS) = {
      fn (i: Int) (k: Thunk(OS)) ->
        do s <- ! int_to_str i;
        ! write_str s k
    } end

    pub def write_int_line : Thunk(Int -> Thunk(OS) -> OS) = {
      fn (i: Int) (k: Thunk(OS)) ->
        do s <- ! int_to_str i;
        ! write_line s k
    } end

    pub def panic : Thunk(String -> OS) = {
      fn (msg: String) ->
        do msg <- ! str_append "Program panicked with message: " msg;
        ! write_line msg { ! exit 1 }
    } end
  end

  module AvlTree where
    pub data AVL (A : VType) where
      | Leaf()
      | Node(AVL A, A, Int, AVL A)
    end

    alias Cmp (A : VType) = U(A -> A -> F(Bool)) end

    def fn max_int (x : Int) (y : Int) : F(Int) =
      do b <- ! int_gt x y;
      match b
      | True() -> ret x
      | False() -> ret y
      end
    end

    pub def fn leaf (A : VType) : F(AVL A) =
      ret Leaf()
    end

    pub def fn singleton (A : VType) (x : A) : F(AVL A) =
      do lf <- ! leaf @(A);
      ret Node(Leaf(), x, 1, Leaf())
    end

    pub def fn height (A : VType) (tree : AVL A) : F(Int) =
      match tree
      | Leaf() -> ret 0
      | Node(l, n, h, r) -> ret h
      end
    end

    pub def fn fix_height (A : VType) (tree : AVL A) : F(AVL A) =
      match tree
      | Leaf() -> ret Leaf()
      | Node(l, n, h, r) ->
        do hl <- ! height @(A) l;
        do hr <- ! height @(A) r;
        do h' <- ! max_int hl hr;
        do h' <- ! add h' 1;
        ret Node(l, n, h', r)
      end
    end

    pub def fn balance_factor (A : VType) (tree : AVL A) : F(Int) =
      match tree
      | Leaf() -> ret 0
      | Node(l, n, h, r) ->
        do hl <- ! height @(A) l;
        do hr <- ! height @(A) r;
        ! sub hl hr
      end
    end

    pub def fn left (A : VType) (tree : AVL A) : F(AVL A) =
      match tree
      | Leaf() -> ret Leaf()
      | Node(l, n, h, r) -> ret l
      end
    end

    pub def fn right (A : VType) (tree : AVL A) : F(AVL A) =
      match tree
      | Leaf() -> ret Leaf()
      | Node(l, n, h, r) -> ret r
      end
    end

    pub def rec fn min_element (A : VType) (tree : AVL A) (cmp : Cmp A) : F(Option A) =
      match tree
      | Leaf() -> ret None()
      | Node(l, n, h, r) ->
        do l' <- ! min_element @(A) l cmp;
        match l'
        | Some(x) -> ret Some(x)
        | None() -> ret Some(n)
        end
      end
    end

    pub def fn rotate_right (A : VType) (tree : AVL A) : F(AVL A) =
      match tree
      | Leaf() -> ret Leaf()
      | Node(l, n, h, r) ->
        match l
        | Leaf() -> ret Leaf()
        | Node(ll, ln, lh, lr) ->
          do n_tree <- ! fix_height @(A) Node(lr, n, h, r);
          ! fix_height @(A) Node(ll, ln, lh, n_tree)
        end
      end
    end

    pub def fn rotate_left (A : VType) (tree : AVL A) : F(AVL A) =
      match tree
      | Leaf() -> ret Leaf()
      | Node(l, n, h, r) ->
        match r
        | Leaf() -> ret Leaf()
        | Node(rl, rn, rh, rr) ->
          do n_tree <- ! fix_height @(A) Node(l, n, h, rl);
          ! fix_height @(A) Node(n_tree, rn, rh, rr)
        end
      end
    end

    pub def fn balance (A : VType) (tree : AVL A) : F(AVL A) =
      match tree
      | Leaf() -> ret Leaf()
      | Node(l, n, h, r) ->
        do bf <- ! balance_factor @(A) tree;
        do g_1 <- ! int_gt bf 1;
        match g_1
        | True() ->
          do l_bf <- ! balance_factor @(A) l;
          do l_0 <- ! int_lt l_bf 0;
          match l_0
          | True() -> 
            do l_tree' <- ! rotate_left @(A) l;
            do n_h <- ! height @(A) tree;
            ! rotate_right @(A) Node(l_tree', n, n_h, r)
          | False() ->
            ! rotate_right @(A) tree
          end
        | False() ->
          do l_m1 <- ! int_lt bf -1;
          match l_m1
          | True() ->
            do r_bf <- ! balance_factor @(A) r;
            do g_0 <- ! int_gt r_bf 0;
            match g_0
            | True() -> 
              do r_tree' <- ! rotate_right @(A) r;
              do n_h <- ! height @(A) tree;
              ! rotate_left @(A) Node(l, n, n_h, r_tree')
            | False() ->
              ! rotate_left @(A) tree
            end
          | False() -> ret tree
          end
        end
      end
    end

    pub def rec fn insert (A : VType) (x : A) (tree : AVL A) (cmp : Cmp A) : F(AVL A) =
      match tree
      | Leaf() -> ! singleton @(A) x
      | Node(l, n, h, r) ->
        do b <- ! cmp x n;
        match b
        | True() ->
          do l' <- ! insert @(A) x l cmp;
          do n_tree <- ! fix_height @(A) Node(l', n, h, r);
          ! balance @(A) n_tree
        | False() ->
          do r' <- ! insert @(A) x r cmp;
          do n_tree <- ! fix_height @(A) Node(l, n, h, r');
          ! balance @(A) n_tree
        end
      end
    end

    pub def rec fn search (A : VType) (x : A) (tree : AVL A) (cmp_eq : Cmp A) (cmp_lt : Cmp A) : F(Option A) =
      match tree
      | Leaf() -> ret None()
      | Node(l, n, h, r) ->
        do b <- ! cmp_eq x n;
        match b
        | True() -> ret Some(n)
        | False() ->
          do b <- ! cmp_lt x n;
          match b
          | True() -> ! search @(A) x l cmp_eq cmp_lt
          | False() -> ! search @(A) x r cmp_eq cmp_lt
          end
        end
      end
    end

    pub def rec fn change (A : VType) (x : A) (tree : AVL A) (cmp_eq : Cmp A) (cmp_lt : Cmp A) : F(AVL A) =
      match tree
      | Leaf() -> ret tree
      | Node(l, n, h, r) ->
        do b <- ! cmp_eq x n;
        match b
        | True() ->
          ret Node(l, x, h, r)
        | False() ->
          do b <- ! cmp_lt x n;
          match b
          | True() ->
            do l' <- ! change @(A) x l cmp_eq cmp_lt;
            ret Node(l', n, h, r)
          | False() ->
            do r' <- ! change @(A) x r cmp_eq cmp_lt;
            ret Node(l, n, h, r')
          end
        end
      end
    end

    pub def rec fn delete (A : VType) (x : A) (tree : AVL A) (cmp_eq : Cmp A) (cmp_lt : Cmp A) : F(AVL A) =
      match tree
      | Leaf() -> ret tree
      | Node(l, n, h, r) ->
        do b <- ! cmp_eq x n;
        match b
        | True() ->
          match l
          | Leaf() -> ret r
          | Node(ll, ln, lh, lr) ->
            match r
            | Leaf() -> ret l
            | Node(rl, rn, rh, rr) ->
              do right_min <- ! min_element @(A) r cmp_lt;
              match right_min
              | None() -> ret l
              | Some(m) ->
                do r' <- ! delete @(A) m r cmp_eq cmp_lt;
                do n_tree <- ! fix_height @(A) Node(l, m, h, r');
                ! balance @(A) n_tree
              end
            end
          end
        | False() ->
          do bl <- ! cmp_lt x n;
          match bl
          | True() ->
            do l' <- ! delete @(A) x l cmp_eq cmp_lt;
            do n_tree <- ! fix_height @(A) Node(l', n, h, r);
            ! balance @(A) n_tree
          | False() ->
            do r' <- ! delete @(A) x r cmp_eq cmp_lt;
            do n_tree <- ! fix_height @(A) Node(l, n, h, r');
            ! balance @(A) n_tree
          end
        end
      end
    end

    pub def rec fn equal (A : VType) (tree1 : AVL A) (tree2 : AVL A) (cmp_eq : Cmp A) : F(Bool) =
      match tree1
      | Leaf() ->
        match tree2
        | Leaf() -> ret True()
        | Node(_, _, _, _) -> ret False()
        end
      | Node(l1, n1, h1, r1) ->
        match tree2
        | Leaf() -> ret False()
        | Node(l2, n2, h2, r2) ->
          do b3 <- ! cmp_eq n1 n2;
          match b3
          | True() ->
            do b1 <- ! equal @(A) l1 l2 cmp_eq;
            do b2 <- ! equal @(A) r1 r2 cmp_eq;
            ! and b1 b2
          | False() -> ret False()
          end
        end
      end
    end

    pub def rec fn pre_traversal (A : VType) (tree : AVL A) (fmt : U(A -> F(String))) (next : U OS) : OS =
      match tree
      | Leaf() -> ! next
      | Node(left, v, h, right) ->
        do r1 <- ! fmt v;
        do r2 <- ! str_append r1 " h:";
        do r3 <- ! int_to_str h;
        do res <- ! str_append r2 r3;
        ! write_line res {
          ! pre_traversal @(A) left fmt {
            ! pre_traversal @(A) right fmt {! next}}}
      end
    end
  end

  module Hash where
    data Hash (K : VType) (V : VType) where
      | Hash(AVL (Pair K V), Cmp (Pair K V), Cmp (Pair K V), Cmp (Pair K V))
    end

    pub def fn hash_new (K : VType) (V : VType) (insert_key_cmp : Cmp K) (search_key_cmp : Cmp K) (equal_value_cmp : Cmp V) : F(Hash K V) =
      do body <- ! leaf @(Pair K V);
      ret Hash(body, {
        fn p1 p2 ->
          match p1
          | Cons(k1, v1) ->
            match p2
            | Cons(k2, v2) -> ! insert_key_cmp k1 k2
            end
          end
      }, {
        fn p1 p2 -> 
          match p1
          | Cons(k1, v1) ->
            match p2
            | Cons(k2, v2) -> ! search_key_cmp k1 k2
            end
          end
      }, {
        fn p1 p2 ->
          match p1
          | Cons(k1, v1) ->
            match p2
            | Cons(k2, v2) ->
              do b1 <- ! equal_value_cmp v1 v2;
              do b2 <- ! search_key_cmp k1 k2;
              ! and b1 b2
            end
          end
      })
    end

    pub def fn hash_insert (K : VType) (V : VType) (k : K) (v : V) (tree : Hash K V) : F(Hash K V) =
      match tree
      | Hash(body, insert_cmp, search_cmp, equal_cmp) ->
        do body' <- ! insert @(Pair K V) Cons(k,v) body insert_cmp;
        ret Hash(body', insert_cmp, search_cmp, equal_cmp)
      end
    end

    # in search, a default value for v is needed, because the type of v is unknown
    pub def fn hash_search (K : VType) (V : VType) (k : K) (default : V) (hash : Hash K V) : F(Option V) =
          match hash
          | Hash(body, insert_cmp, search_cmp, equal_cmp) ->
            do res <- ! search @(Pair K V) Cons(k, default) body search_cmp insert_cmp;
            match res
            | None() -> ret None()
            | Some(p) ->
              match p
              | Cons(k, v) -> ret Some(v)
              end
            end
          end
    end

    pub def fn hash_delete (K : VType) (V : VType) (k : K) (default : V) (hash : Hash K V) : F(Hash K V) =
      match hash
      | Hash(body, insert_cmp, search_cmp, equal_cmp) -> 
        do body' <- ! delete @(Pair K V) Cons(k, default) body search_cmp insert_cmp;
        ret Hash(body', insert_cmp, search_cmp, equal_cmp)
      end
    end

    pub def fn hash_change (K : VType) (V : VType) (k : K) (v : V) (hash : Hash K V) : F(Hash K V) =
      match hash
      | Hash(body, insert_cmp, search_cmp, equal_cmp) ->
        do body' <- ! change @(Pair K V) Cons(k, v) body search_cmp insert_cmp;
        ret Hash(body', insert_cmp, search_cmp, equal_cmp)
      end
    end

    pub def fn hash_equal (K : VType) (V : VType) (hash1 : Hash K V) (hash2 : Hash K V) : F(Bool) =
      match hash1
      | Hash(body1, insert_cmp1, search_cmp1, v_cmp1) ->
        match hash2
        | Hash(body2, insert_cmp2, search_cmp2, v_cmp2) ->
          ! equal @(Pair K V) body1 body2 v_cmp1
        end
      end
    end
  end
end
