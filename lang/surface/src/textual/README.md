# Textual (Parsed Surface Syntax)

`textual` defines the concrete surface syntax and produces the first AST from
source text. It owns lexing, parsing, and span collection, and stores parsed
nodes in arenas keyed by lightweight IDs.

## Role in the pipeline

```markdown
textual -> bitter -> scoped -> statics
```

This phase is responsible for turning source text into structured syntax with
accurate span information, but it does not perform desugaring or name
resolution.

## Data model

- `TextArena` stores parsed definitions, patterns, copatterns, terms, and
  declarations keyed by IDs (`DefId`, `PatId`, `CoPatId`, `TermId`, `DeclId`).
- `SpanArena` stores `Span` values for every textual entity so later phases can
  report precise locations.
- `Parser` combines `TextArena` and `SpanArena` and is passed through the
  LALRPOP-generated parser to allocate nodes as they are parsed.

## Lexing and parsing

- `lexer` uses `logos` to tokenize the input, skipping line comments (`--`) and
  nested block comments (`/-` ... `-/`).
- `parser` is generated by LALRPOP from `parser.lalrpop`. It consumes tokens and
  builds the textual AST by calling into `Parser`.
- `escape` expands string and char escape sequences after parsing literals.

## Spans and lookup helpers

`span` implements `SpanView` for textual IDs and provides helpers on
`SpanArena` for cursor/region lookup and for ordering entities by precision.

## Errors and formatting

- `err` formats parser errors with file path and location context.
- `fmt::ugly` renders textual syntax back into a safe surface form for
  debugging and diagnostics.
