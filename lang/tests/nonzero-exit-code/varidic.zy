codata Varidic (A: VType) (B: CType) where
  | .more : A -> Varidic A B
  | .done : B
end

// A ->* B == List A -> B

// restore
def rec fn l (A: VType) (B: CType) (fv: U (Varidic A B)): List A -> B = fn xs ->
  match xs
  | +Nil() -> ! fv .done
  | +Cons(x, xs) -> ! l @(A) @(B) { ! fv .more x } xs
  end
end

// capture
def fn r (A: VType) (B: CType) (fl: U (List A -> B)): Varidic A B =
  let rec fn r (k: U (List A -> B)): Varidic A B =
    comatch
    | .more x -> ! r { fn xs -> ! k +Cons(x, xs) }
    | .done -> ! k +Nil()
    end
  in
  ! r { fn xs -> ! fl xs }
end

// continuation based mich wand

// ! r @(B) @(A) { ! l @(B) @(A) fv } == fv
// forall fv: U (Varidic A B)

// ! l @(B) @(A) { ! r @(B) @(A) fl } == fl
// forall fl: U (List A -> B)


def rec fn printl (xs: List String) (kont: U OS) : OS =
  match xs
  | +Nil() -> ! kont
  | +Cons(x, xs) ->
    do ! write_line x;
    ! printl xs kont
  end
end



def rec fn printv: Varidic String (U OS -> OS) =
  ! r @(String) @(U OS -> OS) printl
end

main
  do ! l @(String) @(U OS -> OS) { ! r @(String) @(U OS -> OS) printl } (+Cons("hello", +Cons("world", +Nil())));
  do ! r @(String) @(U OS -> OS) { ! l @(String) @(U OS -> OS) printv } .more "hello" .more "world" .done;
  ! exit 0
end
