def ! triv : Top = comatch end end

alias ExnK (E: VType) (A: VType) : CType =
  forall (R: CType) . Thk (E -> R) -> Thk (A -> R) -> R
end

-- Pass the algebra of R along with the type quantifier R
alias ExnKT (E: VType) (M: VType -> CType) (A: VType) : CType =
  forall (R: CType) . Thk (Algebra M R) -> Thk (E -> R) -> Thk (A -> R) -> R
end

def ! mo-exnk (E: VType) : Monad (ExnK E) =
  comatch
  | .return A a -> fn R ke ka ->
    ! ka a
  | .bind A A' m f -> fn R ke ka ->
    ! m R ke { fn a -> ! f a R ke ka }
  end
end

def ! mt-exnkt (E: VType) : MonadTrans (ExnKT E) =
  fn (M: VType -> CType) (mo: Thk (Monad M)) ->
  let ! mt' =
    @[debug("outer")]
    monadic fn (E: VType) ->
      @[debug("inner")]
      let mo-exnk = mo-exnk in
      comatch
      | .monad -> ! mo-exnk E
      | .lift A m ->
        do a <- ! m; ! mo-exnk E .return A a
      end
    :
      forall (E: VType) . codata
      | .monad : Monad (ExnK E)
      | .lift  : forall (A: VType) . Thk (Ret A) -> ExnK E A
      end
    end M mo E triv
  in
  comatch
  | .monad -> comatch
    | .return A -> ! mt' .monad .return A triv
    | .bind A A' -> ! mt' .monad .bind A triv A' triv
    end
  | .lift A -> ! mt' .lift A triv
  end
end

main ! exit 0 end
