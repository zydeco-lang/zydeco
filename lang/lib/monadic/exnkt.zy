alias ExnK (E: VType) (A: VType) : CType =
  forall (R: CType) . Thk (E -> R) -> Thk (A -> R) -> R
end

// Change `Ret` in Exn to `M`
alias ExnKT (E: VType) (M: VType -> CType) (A: VType) : CType =
  forall (R: CType) . Thk (Algebra M R) -> Thk (E -> R) -> Thk (A -> R) -> R
end

def ! mo-exnk (E: VType) : Monad (ExnK E) =
  comatch
  | .return A a -> fn R ke ka ->
    ! ka a
  | .bind A A' m f -> fn R ke ka ->
    ! m R ke { fn a -> ! f a R ke ka }
  end
end

def ! _ =
  monadic
    comatch end
  :
    Top
  end
end

def ! alg-exnk-os (E: VType) (ke: Thk (E -> OS)) : Algebra (ExnK E) OS =
  comatch
  | .bindA A m f ->
    ! m OS ke f
  end
end

def ! _ =
  monadic
    fn (R: CType) (r: Thk R) -> ! r
  :
    forall (R: CType) . Thk R -> R
  end (ExnK String) { ! mo-exnk String } OS { ! alg-exnk-os String panic }
end

// def ! mo-exnkt (E: VType) (M: VType -> CType)
//   (mo: Thk (Monad M))
// : Monad (ExnKT E M) =
//   let ! triv : Top = comatch end in
//   let ! mo' =
//     monadic
//       // inlining `! mo-exnk`
//       fn (E: VType) -> comatch
//       | .return A a -> fn R ke ka ->
//         ! ka a
//       | .bind A A' m f -> fn R ke ka ->
//         ! m R ke { fn a -> ! f a R ke ka }
//       end
//     :
//       // fn (E: VType) -> Monad (ExnK E)
//       forall (E: VType) . Monad (fn (A: VType) -> forall (R: CType) . Thk (E -> R) -> Thk (A -> R) -> R)
//     end M mo E triv
//   in
//   comatch
//   | .return A -> ! mo' .return A triv
//   | .bind A A' -> ! mo' .bind A triv A' triv
//   end
// end


// alias MonadTrans' (T: (VType -> CType) -> VType -> CType) (M: VType -> CType) : CType =
//   codata
//   | .monad : Monad (T M)
//   | .lift : forall (A: VType) . Thk (M A) -> T M A
//   end
// end

// def ! mt-exnt (E: VType) (M: VType -> CType) (mo: Thk (Monad M)) : MonadTrans' (ExnT E) M =
//   use mo monadic
//     let ! mo-exn : Monad (Exn E) = 
//       // inlining `! mo-exn E`
//       comatch
//       | .return A a ->
//         ret +Right(a)
//       | .bind A A' m f ->
//         do a? <- ! m;
//         match a?
//         | +Left(e) -> ret +Left(e)
//         | +Right(a) -> ! f a
//         end
//       end
//     in
//     let ! mt-exnt : MonadTrans' (ExnT E) Ret = 
//       comatch
//       | .monad -> ! mo-exn
//       | .lift A m ->
//         do a <- ! m;
//         ! mo-exn .return A a
//       end
//     in
//     ! mt-exnt
//   end
// end






main ! exit 0 end
