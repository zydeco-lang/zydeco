alias Exn (E: VType) (A: VType) : CType =
  Ret (Either E A)
end

def ! mo-exn (E: VType) : Monad (Exn E) =
  comatch
  | .return A a ->
    ret +Right(a)
  | .bind A A' m f ->
    do a? <- ! m;
    match a?
    | +Left(e) -> ret +Left(e)
    | +Right(a) -> ! f a
    end
  end
end

// test algebra generation for ret and bind
def ! mo-return (E: VType) (mo: U (Monad (Exn E))) : Exn E Int =
  with mo
  begin
    do a <- ret 1;
    ret a
  end
end

// test algebra generation for thunk
def ! mo-thunk (E: VType) (mo: U (Monad (Exn E))) : Exn E Int =
  with mo
  begin
    do _ <- ret 1;
    ! { ret 1 }
  end
end

// test algebra generation for thunk at argument position
def ! mo-thunk-arg (E: VType) (mo: U (Monad (Exn E))) : Exn E Int =
  with mo
  begin
    do _ <- ret 1;
    (fn (x: Thunk _) -> ! x) { ret 1 }
  end
end

// test algebra generation for forall vtype
def ! mo-forallv (E: VType) (mo: U (Monad (Exn E))) : forall (X: VType) . U Top -> X -> Exn E X =
  with mo
  begin
    do _ <- ret 1;
    fn (X: VType) (a: X) -> ret a
  end
end

// test algebra generation for forall ctype
def ! mo-forallc (E: VType) (mo: U (Monad (Exn E))) : forall (X: CType) . U (Algebra (Exn E) X) -> U X -> X =
  with mo
  begin
    do _ <- ret 1;
    fn (X: CType) (a: U X) -> ! a
  end
end

main
  do i? <- ! mo-forallv String { ! mo-exn String } Int { comatch end } 0;
  match i?
  | +Left(e) -> ! exit 1
  | +Right(i) -> ! exit i
  end
end

