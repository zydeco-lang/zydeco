def fn bind_arrow
  (M: VType -> CType)
  (A: VType)
  (B: CType) (alg: U (Algebra M B))
: Algebra M (A -> B) =
  comatch
  | .bindA X (m: U (M X)) (f: U (X -> A -> B)) -> fn a ->
    ! alg .bindA X m { fn x -> ! f x a }
  end
end

codata With (B1: CType) (B2: CType) where
  | .l: B1
  | .r: B2
end

def fn bind_with
  (M: VType -> CType)
  (B1: CType) (alg1: U (Algebra M B1))
  (B2: CType) (alg2: U (Algebra M B2))
: Algebra M (With B1 B2) =
  comatch
  | .bindA X (m: U (M X)) (f: U (X -> With B1 B2)) ->
    comatch
    | .l -> ! alg1 .bindA X m { fn x -> ! f x .l }
    | .r -> ! alg2 .bindA X m { fn x -> ! f x .r }
    end
  end
end

def fn bind_ret
  (M: VType -> CType) (mo: U (Monad M))
  (A: VType)
: Algebra M (M A) =
  comatch
  | .bindA X m f ->
    ! mo .bind X A m f
  end
end

def fn bind_forall_ctype
  (M: VType -> CType)
  (B: CType -> CType) (algB: U (forall (Y: CType) . U (Algebra M Y) -> Algebra M (B Y)))
: Algebra M (forall (Y: CType) . U (Algebra M Y) -> B Y) =
  comatch
  | .bindA X (m: U (M X)) (f: U (X -> (forall (Y: CType) . U (Algebra M Y) -> B Y))) ->
    comatch Y algY ->
      ! algB Y algY .bindA X m { fn a -> ! f a Y algY }
    end
  end
end

def fn bind_forall_ctype_constructor
  (M: VType -> CType)
  (B: (CType -> CType) -> CType)
  (algB: U (forall (Y: CType -> CType) (Z: CType) . U (U (Algebra M Z) -> Algebra M (Y Z)) -> Algebra M (B Y)))
: Algebra M (forall (Y: CType -> CType) (Z: CType) . U (U (Algebra M Z) -> Algebra M (Y Z)) -> B Y) =
  comatch
  | .bindA X (m: U (M X))
    (f: U (X -> (forall (Y: CType -> CType) (Z: CType) . U (U (Algebra M Z) -> Algebra M (Y Z)) -> B Y))) ->
    comatch Y Z algZYZ ->
      ! algB Y Z algZYZ .bindA X m { fn a -> ! f a Y Z algZYZ }
    end
  end
end

main
  ! exit 0
end
