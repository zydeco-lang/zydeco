def ! triv : Top = comatch end end

alias Exn (E: VType) (A: VType) : CType =
  Ret (Either E A)
end

# Change `Ret` in Exn to `M`
alias ExnT (E: VType) (M: VType -> CType) (A: VType) : CType =
  M (Either E A)
end

def ! mo-exn (E: VType) : Monad (Exn E) =
  comatch
  | .return A a ->
    ret +Right(a)
  | .bind A A' m f ->
    do a? <- ! m;
    match a?
    | +Left(e) -> ret +Left(e)
    | +Right(a) -> ! f a
    end
  end
end

def ! mt-exnt (E: VType) : MonadTrans (ExnT E) =
  fn (M: VType -> CType) (mo: Thk (Monad M)) ->
  let ! mt' =
    @[debug("outer")]
    monadic fn (E: VType) ->
      @[debug("inner")]
      let mo-exn = mo-exn in
      comatch
      | .monad -> ! mo-exn E
      | .lift A m ->
        do a <- ! m; ! mo-exn E .return A a
      end
    :
      forall (E: VType) . codata
      | .monad : Monad (Exn E)
      | .lift  : forall (A: VType) . Thk (Ret A) -> Exn E A
      end
    end M mo E triv
  in
  comatch
  | .monad -> comatch
    | .return A -> ! mt' .monad .return A triv
    | .bind A A' -> ! mt' .monad .bind A triv A' triv
    end
  | .lift A -> ! mt' .lift A triv
  end
end

main ! exit 0 end
