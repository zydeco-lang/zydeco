-- Monad transformers
-- Two flavors of exception monad transformers are presented,
-- one for the monad that uses `Ret` in its type signature,
-- and the other uses CPS (`Kont`).

-- The interface for monads
-- codata Monad (M: VType -> CType) where
--   | .return : forall (A: VType) .
--     A -> M A
--   | .bind : forall (A: VType) (A': VType) .
--     Thk (M A) -> Thk (A -> M A') -> M A'
-- end

-- The interface for the algebra
-- alias Algebra (M: VType -> CType) (R: CType) : CType =
--   forall (A: VType) . Thk (M A) -> Thk (A -> R) -> R
-- end

-- The interface for the monad transformer
-- codata MonadTrans (T: (VType -> CType) -> VType -> CType) where
--   | .monad : forall (M: VType -> CType) .
--     Thk (Monad M) -> Monad (T M)
--   | .lift : forall (M: VType -> CType) (A: VType) .
--     Thk (Monad M) -> Thk (M A) -> T M A
-- end


-- Change `Ret` in Exn to `M`
codata ExnT (E: VType) (M: VType -> CType) (A: VType) where
  | .done : M (Either E A)
end

def ! mtexn (E: VType) : MonadTrans (ExnT E) = fn M mo ->
  comatch
  | .monad ->
    comatch
    | .return A a -> fn .done ->
      ! mo .return (Either E A) +Right(a)
    | .bind A A' m f -> fn .done ->
      ! mo .bind (Either E A) (Either E A') { ! m .done }
      { fn a? ->
          match a?
          | +Left(e) -> ! mo .return (Either E A') +Left(e)
          | +Right(a) -> ! f a .done
          end }
    end
  | .lift A m -> fn .done ->
    ! mo .bind A (Either E A) m
    { fn a ->
      ! mo .return (Either E A) +Right(a) }
  end
end


-- Add the algebra for the output type of the continuation $R$
codata ExnKT (E: VType) (R: CType) (M: VType -> CType) (A: VType) where
  | .run : Thk (Algebra M R) -> Thk (E -> R) -> Thk (A -> R) -> R
end

def ! mtexnk (E: VType) (R: CType) : MonadTrans (ExnKT E R) = fn M mo ->
  comatch
  | .monad ->
    comatch
    | .return A a -> fn .run alg -> fn ke ka ->
      ! ka a
    | .bind A A' m f -> fn .run alg -> fn ke ka' ->
      do~ ! m .run alg ke; fn a ->
      ! f a .run alg ke ka'
    end
  | .lift A m -> fn .run alg -> fn ke ka ->
    ! alg A m ka
  end
end


main
  ! exit 0
end
