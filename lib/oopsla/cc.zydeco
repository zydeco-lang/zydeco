--| Three different calling conventions and the sum_and_mult example

--| Funciton Type (A -> B)
codata Fn (A: VType) (B: CType) where
  | .push (arg: A) : B
end

--| Function Type with Optional Argument (A ->? B)
codata FnOpt (A: VType) (B: CType) where
  | .some (arg: A) : B
  | .none          : B
end

--| Variadic Function Type (A ->* B)
codata FnVar (A: VType) (B: CType) where
  | .more (arg: A) : FnVar A B
  | .done          : B
end

--| Type of Variadic Function with at least one argument (A ->+ B)
alias FnVarOnce (A: VType) (B: CType) : CType = A -> (FnVar A B) end

-- `!` is the force operator which is used to run suspended computations in thunks
-- `! { ... }` will be evaluated to `...`
-- Here we place `!` in the pattern to mean that we're defining the suspended computation
-- and the surrounding thunk will be generated by the compiler
def ! sum_and_mult =
  (fix (loop: Thk(Int -> FnVar Int (FnOpt Int (Ret Int)))) -> fn sum -> comatch
    -- the following line is the same as `| .more -> fn i -> ...`
    | .more i -> do j <- ! add sum i; ! loop j
    | .done -> comatch
      | .some i -> ! mult sum i
      | .none -> ret sum
      end
    end) 0
end

-- The following is the same as `sum_and_mult` but with more syntactic sugar
def ! sum_and_mult' =
  -- `let` has the same series of syntactic sugar as `def`, such as `let ! x = ... in ...`
  -- Here we introduce another one: `let fix x = ... in ...` constructs a fixed point,
  -- and the function parameters can also be introduced in the `let` or `def` bindings.
  let fix loop (sum: Int) : FnVar Int (FnOpt Int (Ret Int)) =
    comatch
    | .more i -> do j <- ! add sum i; ! loop j
    | .done -> comatch
      | .some i -> ! mult sum i
      | .none -> ret sum
      end
    end
  in
  ! loop 0
end

main
  -- calculate (1 + 2 + 3) * 4
  do r <- ! sum_and_mult .more 1 .more 2 .more 3 .done .some 4;
  -- subtract 24 from the result to get exit code 0
  do e <- ! sub r 24;
  ! exit e
end
