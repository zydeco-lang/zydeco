# Overview

This document is a high-level overview of the artifact for our OOPSLA paper "Notions of Stack-Manipulating Computation and Relative Monads".

## Introduction

The artifact contains the implementation of a call-by-push-value (CBPV) calculus named Zydeco and examples mentioned in our OOPSLA paper. In the paper, we claimed that relative monads can model common stack-manipulating computations used in functional programming. Additionally, we described a generalized do-notation called "monadic blocks" that enables embedded CBPV programming by reinterpreting Zydeco code with any monad designated by the user. We further claimed that any user-implemented relative monad in Zydeco can have their relative monad transformers automatically derived. In the submitted artifact, we provide all supporting materials for the claims made in the paper.

+ To prove that Zydeco is usable as a functional programming language, we provide a Rust implemenation of Zydeco System-FÏ‰-style type checker, a small-step interpreter, and a minimal standard library (`core.zydeco`). We also provide examples of Zydeco programs (`polynormial.zydeco`, `sum_and_mult.zydeco`, and `cbv.zydeco`) shown in the paper, as well as ways to run and test their correctness.
+ To prove that common stack-manipulating computations can be modeled by relative monads, we define relative monads and their implementations in Zydeco (`monads.zydeco`, `exn.zydeco`, and `free.zydeco`). Based on these implementations, we further show how to utilize them in effectful Zydeco programs.
+ To support the introduction of monadic blocks, we implement a source-to-source translation called "algebra translation" that works during the type checking phase to traverse the program inside the monadic blocks and generate structures to allow the piece of code to work with the user-specified ambient monad. We also introduce algebras of relative monads in Zydeco and how to extend algebras on all type (constructors), which is crucial for the implementation of monadic blocks. To observe the code generated by monadic blocks, we provide tools for the reviewer to check the result of the algebra translation to witness the correctness of our implementation.
+ As an application of monadic blocks, we show how relative monad transformers can be automatically derived from user-implemented relative monads in Zydeco. We generate the relative monad transformer implementations for the `Exn` and `ExnK` monads, and compare to our manual implementations (`exnt.zydeco` and `exnkt.zydeco`) to check their correctness.
+ To further demonstrate how monadic blocks can be used to practice embedded CBPV programming, we provide a few other program examples that uses monadic blocks to implement stack-manipulating computations. 

Note that the monadic blocks are slightly improved from its original version in the paper in that we now support direct reference to *global* types and terms within the monadic blocks, whereas the original version disallowed anything defined outside the monadic blocks. Calling a type or a term "global" means that the type or term can be well-typed only using other global types and terms. Combined with the admissive weakening rule, all global types and terms can now be used anywhere in the program.


## Hardware Dependencies

The artifact doesn't require any specific hardware dependencies. The artifact is tested on a Linux machine, a macOS machine, and a Windows machine. Boardly speaking, the artifact can be expected to work on any machine that has a modern version of Rust (1.80.0 or later) installed.


## Getting Started Guide

1. Access the artifact by pulling the docker image and run it in a container:
```sh
docker run --rm -it lighghteeloo/zydeco:latest
```

2. Run the tests inside the docker container:
```sh
cargo test --release
```
The expected output is that all tests pass, meaning that our implementation has passed the basic sanity checks.


## Step-by-Step Instructions

When running tests, Zydeco is built under the `debug` profile. To run other examples and reuse the tools we provide as binaries, it's recommended to build Zydeco under the `release` profile.

```sh
cargo build --release
```

To run the examples, alias `zydeco` to the `target/release/zydeco` binary and use the `run` sub-command.

```sh
alias zydeco="target/release/zydeco"
zydeco run lang/lib/oopsla/proj.toml --bin=<bin-name>
```

All examples are located under the `lang/lib/oopsla/proj.toml` file.
For example, to run the first example `polynomial`, run the following command:

```sh
zydeco run lang/lib/oopsla/proj.toml --bin=polynomial
```

## Reusability Guide

The artifact is designed to be reusable by other researchers and practitioners.
+ The zydeco binary can be used to interpret Zydeco programs and perform algebra translation.
+ The `core.zydeco` and `data.zydeco` files can be used as a minimal standard library for Zydeco.
