// A monad structure
codata Monad (M: VType -> CType) where
  | .return(): forall (A: VType) . A -> M A
  | .bind(): forall (A: VType) (A': VType) . U (M A) -> U (A -> M A') -> M A'
end

// A monad structure that supports fail
codata MonadErr (M: VType -> CType) where
  | .fail(): forall (A: VType) . Exception -> M A
end

// A monad structure that supports print
codata MonadPrint (M: VType -> CType) where
  | .print(): String -> M Unit
end

codata MonadAlt (M: VType -> CType) where
  | .alt(): forall (A: VType) . U (M A) -> U (M A) -> M A
end

codata MonadReduce (M: VType -> CType) where
  | .reduce(): forall (A: VType) . List (U (M A)) -> U (M A) -> M A
end

codata MonadTrans (T: (VType -> CType) -> VType -> CType) where
  | .lift(): forall (M: VType -> CType) (A: VType) . U (Monad M) -> U (M A) -> T M A
end

// A comonad structure
codata Comonad (W: CType -> VType) where
  | .extract(): forall (B: CType) . W B -> B
  | .extend(): forall (B: CType) (B': CType) . W B -> U (W B -> B') -> F (W B')
end

// An algebra structure that supports fail
codata Algebra (M: VType -> CType) (B: CType) where
  | .bindA(): forall (A: VType) . U (M A) -> U (A -> B) -> B
end

// An algebra structure that supports fail
codata AlgebraErr (M: VType -> CType) (B: CType) where
  | .failA(): Exception -> B
end

data Exception where
  | ParseError(Int, String)
  | FreeVariable()
  | TypeError()
end

// Continuation-based error monad
codata MExnOS (A: VType) where
  | .run(): U (A -> OS) -> U (Exception -> OS) -> OS
end

data Value where
  | Bool(Bool)
  | Int(Int)
  | Thunk(U Compu)
end

codata Compu where
  | .app(): Value -> Compu
  | .bind(): String -> SCompu -> U (Value -> Compu) -> Compu
  | .os(): MExnOS Value
end

data SValue where
  | Var(String)
  | Bool(Bool)
  | Int(Int)
  | Thunk(SCompu)
end

data SCompu where
  | Lam(String, SCompu)
  | App(SCompu, SValue)
  | Ret(SValue)
  | Bind(SCompu, String, SCompu)
  | Force(SValue)
  | Rec(String, SCompu)
  | If(SValue, SCompu, SCompu)
  // | Add(SValue, SValue)
  // | Mul(SValue, SValue)
  | Env(SCompu)
end

module MExnOS where
  def fn mexn : Monad MExnOS =
    comatch
    | .return() -> fn A a ->
      comatch
      | .run() -> fn ka _ -> ! ka a
      end
    | .bind() -> fn A A' m f ->
      comatch
      | .run() -> fn ka ke ->
        ! m .run() { fn a -> ! f a .run() ka ke } ke
      end
    end
  end

  def fn mexn-err : MonadErr MExnOS =
    comatch
    | .fail() -> fn A e ->
      comatch
      | .run() -> fn _ ke -> ! ke e
      end
    end
  end

  def fn mexn-print : MonadPrint MExnOS =
    comatch
    | .print() -> fn s ->
      comatch
      | .run() -> fn ka _ ->
        do ! write_line s;
        ! ka Unit()
      end
    end
  end

  def fn mexn-alt : MonadAlt MExnOS =
    comatch
    | .alt() -> fn A m1 m2 ->
      comatch
      | .run() -> fn ka ke ->
        ! m1 .run() ka { fn _ ->
          ! m2 .run() ka ke
        }
      end
    end
  end

  def fn mexn-reduce : MonadReduce MExnOS =
    comatch
    | .reduce() -> fn A ms m ->
      do m~ <- ! foldl @(U (MExnOS A)) @(U (MExnOS A)) ms {
        fn m' m -> ret {
          comatch
          | .run() -> fn ka ke ->
            ! m' .run() ka { fn _ -> ! m .run() ka ke }
          end
        }
      } m;
      ! m~
    end
  end

  def rec fn malg : Algebra MExnOS Compu =
    comatch
    | .bindA() -> fn A m f -> // m : U (MExnOS A), f: U (A -> Compu)
      comatch
      | .app() -> fn a -> // goal: Compu
        ! malg .bindA() @(A) m { fn v -> ! f v .app() a }
      | .bind() -> fn x sc k -> // goal: Compu
        ! malg .bindA() @(A) m { fn v -> ! f v .bind() x sc k }
      | .os() -> // goal: MExnOS Value, use ordinary bind
        ! mexn .bind() @(A) @(Value) m { fn x -> ! f x .os() }
      end
    end
  end

  def rec fn malg-err : AlgebraErr MExnOS Compu =
    comatch
    | .failA() -> fn e ->
      rec unwind -> comatch
      | .app() -> fn _ -> ! unwind
      | .bind() -> fn _ _ _ -> ! unwind
      | .os() -> ! mexn-err .fail() @(Value) e
      end
    end
  end
end

module Print where
  codata PrintSCbpv where
    | .value(): SValue -> U OS -> OS
    | .compu(): SCompu -> U OS -> OS
  end
  def rec fn print-scbpv : PrintSCbpv =
    comatch
    | .value() -> fn sv kont ->
      match sv
      | Var(x) -> ! write_str x kont
      | Bool(b) -> ! if @(OS) b { ! write_str "true" kont } { ! write_str "false" kont }
      | Int(i) ->
        do i <- ! int_to_str i;
        ! write_str i kont
      | Thunk(sc) ->
        // Note: `do <comp1>; <comp2>` is a syntactic sugar for `<comp1> { <comp2> }`
        do ! write_str "{ ";
        do ! print-scbpv .compu() sc;
        do ! write_str " }";
        ! kont
      end
    | .compu() -> fn sc kont ->
      match sc
      | Lam(x, sc) ->
        do ! write_str "fn ";
        do ! write_str x;
        do ! write_str " -> ";
        do ! print-scbpv .compu() sc;
        ! kont
      | App(sc, sv) ->
        do ! write_str "(";
        do ! print-scbpv .compu() sc;
        do ! write_str " ";
        do ! print-scbpv .value() sv;
        do ! write_str ")";
        ! kont
      | Ret(sv) ->
        do ! write_str "ret ";
        do ! print-scbpv .value() sv;
        ! kont
      | Bind(sc1, x, sc2) ->
        do m <- ! str_append "bind " x;
        do m <- ! str_append m " <- ";
        do ! write_str m;
        do ! print-scbpv .compu() sc1;
        do ! write_str "; ";
        do ! print-scbpv .compu() sc2;
        ! kont
      | Force(sv) ->
        do ! write_str "! ";
        do ! print-scbpv .value() sv;
        ! kont
      | Rec(x, sc) ->
        do ! write_str "rec ";
        do ! write_str x;
        do ! write_str " -> ";
        do ! print-scbpv .compu() sc;
        ! kont
      | If(sv, sc1, sc2) ->
        do ! write_str "if ";
        do ! print-scbpv .value() sv;
        do ! write_str " then ";
        do ! print-scbpv .compu() sc1;
        do ! write_str " else ";
        do ! print-scbpv .compu() sc2;
        ! kont
      | Env(sc) ->
        do ! write_str "env[";
        do ! print-scbpv .compu() sc;
        do ! write_str "]";
        ! kont
      end
    end
  end
  def fn print-svalue : SValue -> U OS -> OS =
    ! print-scbpv .value()
  end
  def fn print-scompu : SCompu -> U OS -> OS =
    ! print-scbpv .compu()
  end

  codata PrintCbpv where
    | .value(): Value -> U OS -> OS
    | .compu(): U Compu -> U OS -> OS
  end
  def rec fn print-cbpv: PrintCbpv =
    comatch
    | .value() -> fn v kont ->
      match v
      | Bool(b) -> ! if @(OS) b { ! write_str "true" kont } { ! write_str "false" kont }
      | Int(i) ->
        do i <- ! int_to_str i;
        ! write_str i kont
      | Thunk(c) ->
        do ! write_str "{ ";
        do ! print-cbpv .compu() c;
        do ! write_str " }";
        ! kont
      end
    | .compu() -> fn c kont ->
      ! write_str "<compu>" kont
    end
  end
  def fn print-value : Value -> U OS -> OS =
    ! print-cbpv .value()
  end
  def fn print-compu : U Compu -> U OS -> OS =
    ! print-cbpv .compu()
  end
end

module Env where
  data EnvT where
    | Empty()
    | Extend(String, Value, EnvT)
  end

  codata EnvO where
    | .lookup(): String -> Ret (Option Value)
    | .extend(): String -> Value -> EnvO
    | .print(): U OS -> OS
  end

  def rec fn envo (env: EnvT) : EnvO =
    comatch
    | .lookup() -> fn x ->
      match env
      | Empty() -> ret None()
      | Extend(x', v, env') ->
        do is-eq? <- ! str_eq x x';
        match is-eq?
        | True() -> ret Some(v)
        | False() -> ! envo env' .lookup() x
        end
      end
    | .extend() -> fn x v ->
      ! envo Extend(x, v, env)
    | .print() -> fn k ->
      do ! write_line "[";
      (rec (p : Thunk (EnvT -> OS)) -> fn env -> match env
      | Empty() -> ! write_line "]" k
      | Extend(x, v, env') ->
        do ! write_str "  ";
        do ! write_str x;
        do ! write_str " = ";
        do ! print-value v;
        do ! write_line ",";
        ! p env'
      end) env
    end
  end
end

module Trace where
  data TraceItem where
    | App(Value)
    // | App(SValue, Value)
    // | Bind(U (Value -> Compu))
    | Bind(String, SCompu, U (Value -> Compu))
  end

  codata TraceO where
    | .print(): U OS -> OS
  end

  def fn traceo (items: List TraceItem) : TraceO =
    comatch
    | .print() -> fn kont ->
      do ! write_line "[";
      do kont <-
        do ! foldl @(TraceItem) @(U OS) items { fn item kont -> ret {
          match item
          | App(v) ->
          // | App(_sv, v) ->
            do ! write_str "  app ";
            do ! print-value v;
            do ! write_line ",";
            ! kont
          // | Bind(_k) ->
          | Bind(x, sc, _k) ->
            do ! write_str "  bind ";
            do ! write_str x;
            do ! write_str ". ";
            do ! print-scompu sc;
            do ! write_line ",";
            ! kont
          end
        }};
        ! write_line "]" kont
      ;
      ! kont
    end
  end
end

/* Parser */

module Parser where
  codata Parser (A: VType) where
    | .run(): String -> Int -> MExnOS (Pair A Int)
  end

  pub def fn mp : Monad Parser =
    comatch
    | .return() -> fn A a ->
      comatch
      | .run() -> fn s i -> ! mexn .return() @(Pair A Int) Cons(a, i)
      end
    | .bind() -> fn A A' ma f ->
      comatch
      | .run() -> fn s i ->
        comatch
        | .run() -> fn ka ke ->
          ! ma .run() s i .run() { fn p -> match p | Cons(a, i) ->
            ! f a .run() s i .run() ka ke
          end } ke
        end
      end
    end
  end

  pub def fn mp-err : MonadErr Parser =
    comatch
    | .fail() -> fn A e ->
      comatch
      | .run() -> fn s i ->
        comatch
        | .run() -> fn _ ke -> ! ke e
        end
      end
    end
  end

  pub def fn mp-alt : MonadAlt Parser =
    comatch
    | .alt() -> fn A m1 m2 ->
      comatch
      | .run() -> fn s i ->
        ! mexn-alt .alt() @(Pair A Int) { ! m1 .run() s i } { ! m2 .run() s i }
      end
    end
  end

  pub def fn mp-cnt (A: VType) (cnt: Int) (m: U (Parser A)) : Parser A =
    comatch | .run() -> fn s i ->
      do len <- ! str_length s;
      do i' <- ! add i cnt;
      ! if~ @(MExnOS (Pair A Int)) { ! int_le i' len } {
        ! m .run() s i
      } {
        ! mexn-err .fail() @(Pair A Int) ParseError(i, "unexpected eof")
      }
    end
  end

  pub def fn p_char (c: Char) : Parser Char =
    ! mp-cnt @(Char) 1 {
      comatch | .run() -> fn s i ->
        ! if~ @(MExnOS (Pair Char Int)) {
          do c' <- ! str_index s i;
          ! char_eq c' c
        } {
          do i' <- ! add i 1;
          ! mexn .return() @(Pair Char Int) Cons(c, i')
        } {
          do msg <- ! char_to_str c;
          do msg <- ! str_append "missing `" msg;
          do msg <- ! str_append msg "`";
          ! mexn-err .fail() @(Pair Char Int) ParseError(i, msg)
        }
      end
    }
  end

  pub def fn p_word (w: String) : Parser String =
    do len <- ! str_length w;
    ! mp-cnt @(String) len {
      comatch | .run() -> fn s i ->
        let rec fn word_match (j: Int) =
          ! if~ @(Ret Bool) { ! int_eq j len } {
            ret True()
          } {
            do l <- ! add i j;
            do c1 <- ! str_index s l;
            do c2 <- ! str_index w j;
            ! if~ @(Ret Bool) { ! char_eq c1 c2 } {
              do j' <- ! add j 1;
              ! word_match j'
            } {
              ret False()
            }
          }
        in
        ! if~ @(MExnOS (Pair String Int)) { ! word_match 0 } {
          do i' <- ! add i len;
          ! mexn .return() @(Pair String Int) Cons(w, i')
        } {
          do msg <- ! str_append "word `" w;
          do msg <- ! str_append msg "` mismatch";
          ! mexn-err .fail() @(Pair String Int) ParseError(i, msg)
        }
      end
    }
  end

  pub def fn p_var : Parser String =
    let fn p_vc (c: Char) : Ret (Option Char) =
      do ascii <- ! char_to_int c;
      let digit = { ! and~ { ! int_lt 47 ascii } { ! int_lt ascii 58 } } in
      let cap = { ! and~ { ! int_lt 64 ascii } { ! int_lt ascii 91 } } in
      let sml = { ! and~ { ! int_lt 96 ascii } { ! int_lt ascii 123 } } in
      ! if~ @(Ret (Option Char))
        { ! or~ digit { ! or~ cap sml } }
        { ret Some(c) }
        { ret None() }
    in
    comatch | .run() -> fn s i ->
      let rec fn var (v: String) (i: Int) =
        do c <- ! str_index s i;
        do c? <- ! p_vc c;
        do i' <- ! add i 1;
        match c?
        | None() ->
          ! if~ @(MExnOS (Pair String Int)) {
            do len <- ! str_length v;
            ! int_eq len 0
          } {
            ! mexn-err .fail() @(Pair String Int) ParseError(i, "variable of length 0")
          } {
            ! mexn .return() @(Pair String Int) Cons(v, i)
          }
        | Some(c) ->
          do c <- ! char_to_str c;
          do v <- ! str_append v c;
          ! var v i'
        end
      in
      ! var "" i
    end
  end

  codata ParserCbpv where
    | .value(): Parser SValue
    | .compu(): Parser SCompu
  end

  pub def rec fn p_cbpv : ParserCbpv =
    comatch
    | .value() ->
      let fn _true =
        do ! mp .bind() @(String) @(SValue) { ! p_word "true" }; fn _ ->
        ! mp .return() @(SValue) Bool(True())
      in
      let fn _false =
        do ! mp .bind() @(String) @(SValue) { ! p_word "false" }; fn _ ->
        ! mp .return() @(SValue) Bool(False())
      in
      let fn _var =
        do ! mp .bind() @(String) @(SValue) p_var; fn v ->
        ! mp .return() @(SValue) Var(v)
      in
      let fn _thunk =
        do ! mp .bind() @(Char) @(SValue) { ! p_char '{' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SValue) { ! p_cbpv .compu() }; fn sc ->
        do ! mp .bind() @(Char) @(SValue) { ! p_char '}' }; fn _ ->
        ! mp .return() @(SValue) Thunk(sc)
      in
      do ! mp-alt .alt() @(SValue) _true;
      do ! mp-alt .alt() @(SValue) _false;
      do ! mp-alt .alt() @(SValue) _var;
      do ! mp-alt .alt() @(SValue) _thunk;
      comatch | .run() -> fn s i ->
        ! mexn-err .fail() @(Pair SValue Int) ParseError(i, "expected value")
      end
    | .compu() ->
      let fn _env =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '(' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) { ! p_word "env" }; fn _ ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) Env(sc)
      in
      let fn _ret =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '(' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) { ! p_word "ret" }; fn _ ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() }; fn sv ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) Ret(sv)
      in
      let fn _bind =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '(' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) { ! p_word "bind" }; fn _ ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc1 ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) p_var; fn v ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc2 ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) Bind(sc1, v, sc2)
      in
      let fn _force =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '!' }; fn _ ->
        // do ! mp .bind() @(String) @(SCompu) { ! p_word "call" }; fn _ ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() }; fn sv ->
        // do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) Force(sv)
      in
      let fn _if =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '(' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) { ! p_word "if" }; fn _ ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() }; fn sv ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc1 ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc2 ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) If(sv, sc1, sc2)
      in
      let fn _lam =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '(' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) { ! p_word "fn" }; fn _ ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(String) @(SCompu) p_var; fn v ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) Lam(v, sc)
      in
      let fn _app =
        do ! mp .bind() @(Char) @(SCompu) { ! p_char '(' }; fn _ ->
        do ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() }; fn sc ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' }; fn _ ->
        do ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() }; fn sv ->
        do ! mp .bind() @(Char) @(SCompu) { ! p_char ')' }; fn _ ->
        ! mp .return() @(SCompu) App(sc, sv)
      in
      do ! mp-alt .alt() @(SCompu) _env;
      do ! mp-alt .alt() @(SCompu) _ret;
      do ! mp-alt .alt() @(SCompu) _bind;
      do ! mp-alt .alt() @(SCompu) _force;
      do ! mp-alt .alt() @(SCompu) _if;
      do ! mp-alt .alt() @(SCompu) _lam;
      do ! mp-alt .alt() @(SCompu) _app;
      comatch | .run() -> fn s i ->
        ! mexn-err .fail() @(Pair SCompu Int) ParseError(i, "expected computation")
      end
    end
  end

  pub def fn p_main (s: String) : MExnOS SCompu =
    do ! mexn .bind() @(Pair SCompu Int) @(SCompu) { ! p_cbpv .compu() .run() s 0 }; fn sci ->
    match sci
    | Cons(sc, i) ->
      ! if~ @(MExnOS SCompu) {
        do len <- ! str_length s;
        ! int_eq i len
      } {
        ! mexn .return() @(SCompu) sc
      } {
        ! mexn-err .fail() @(SCompu) ParseError(i, "not eof after parsing")
      }
    end
  end
end

/* Interpretor */

codata Interp where
  | .value(): SValue -> MExnOS Value
  | .compu(): SCompu -> Compu
end

def rec fn interp (env: U EnvO) : Interp =
  comatch
  | .value() -> fn sv ->
    match sv
    | Var(x) ->
      do x? <- ! env .lookup() x;
      match x?
      | None() -> ! mexn-err .fail() @(Value) FreeVariable()
      | Some(v) ->
        ! mexn .return() @(Value) v
      end
    | Bool(b) ->
      ! mexn .return() @(Value) Bool(b)
    | Int(i) ->
      ! mexn .return() @(Value) Int(i)
    | Thunk(c) ->
      ! mexn .return() @(Value) Thunk({ ! interp env .compu() c })
    end
  | .compu() -> fn sc ->
    let fn type-error = 
      ! mexn-err .fail() @(Value) TypeError()
    in
    match sc
    | Lam(x, sc) ->
      comatch
      | .app() -> fn v ->
        ! interp { ! env .extend() x v } .compu() sc
      | .bind() -> fn _ _ k ->
        do ! malg .bindA() @(Value) type-error; fn v ->
        // the following is unreachable
        ! k v .app() v
      | .os() -> ! type-error
      end
    | App(sc, sv) ->
      do ! malg .bindA() @(Value) { ! interp env .value() sv }; fn v ->
      ! interp env .compu() sc .app() v
    | Ret(sv) ->
      comatch
      | .app() -> fn _ -> ! malg-err .failA() TypeError()
      | .bind() -> fn _ _ k ->
        do ! malg .bindA() @(Value) { ! interp env .value() sv }; fn v ->
        ! k v
      | .os() -> ! interp env .value() sv
      end
    | Bind(sc1, x, sc2) ->
      do ! interp env .compu() sc1 .bind() x sc2; fn v ->
      ! interp { ! env .extend() x v } .compu() sc2
    | Force(sv) ->
      do ! malg .bindA() @(Value) { ! interp env .value() sv }; fn v ->
      match v
      | Bool(_) -> ! malg-err .failA() TypeError()
      | Int(_) -> ! malg-err .failA() TypeError()
      | Thunk(c) -> ! c
      end
    | Rec(x, sc) ->
      ! interp { ! env .extend() x Thunk({ ! interp env .compu() Rec(x, sc) }) } .compu() sc
    | If(sv, c1, c2) ->
      do ! malg .bindA() @(Value) { ! interp env .value() sv }; fn v ->
      match v
      | Bool(b) ->
        match b
        | True() -> ! interp env .compu() c1
        | False() -> ! interp env .compu() c2
        end
      | Int(_) -> ! malg-err .failA() TypeError()
      | Thunk(_) -> ! malg-err .failA() TypeError()
      end
    | Env(sc) -> 
      let rec fn walk (items: List TraceItem): Compu =
        comatch
        | .app() -> fn v ->
          ! walk Cons(App(v), items)
        | .bind() -> fn x sc k ->
          ! walk Cons(Bind(x, sc, k), items)
        | .os() ->
          let mp: U (MExnOS Unit) = {
            comatch | .run() -> fn ka _ ->
              do ! write_line "[[DEBUG]]";
              do ! write_str "[env]: ";
              do ! env .print();
              do ! write_str "[term]: ";
              do ! print-scompu sc;
              do ! write_line "";
              do ! write_str "[stack]: ";
              do ! traceo items .print();
              do ! write_str "Continue? ";
              do ! read_line; fn _ ->
              ! ka Unit()
            end
          } in
          do ! mexn .bind() @(Unit) @(Value) mp; fn _ ->
          let rec fn cowalk (items: List TraceItem): Compu =
            match items
            | Nil() -> ! interp env .compu() sc
            | Cons(item, items) ->
              match item
              | App(v) -> ! cowalk items .app() v
              | Bind(x, sc, k) -> ! cowalk items .bind() x sc k
              end
            end
          in
          ! cowalk items .os()
        end
      in
      ! walk Nil()
    end
  end
end

module Utils where
  def fn value-eq (v1: Value) (v2: Value) (k: U OS) : OS =
    let expect-bool-panic = { ! panic "expected bool value" } in
    let expect-int-panic = { ! panic "expected int value" } in
    let correct = { ! write_line "\\^o^/" k } in
    match v1
    | Bool(b1) ->
      match v2
      | Bool(b2) ->
        do eq? <- ! bool_eq b1 b2;
        match eq?
        | True() -> ! correct
        | False() ->
          do b1 <- ! bool_to_str b1;
          do b2 <- ! bool_to_str b2;
          do msg <- ! str_append b1 " != ";
          do msg <- ! str_append msg b2;
          do msg <- ! str_append "wrong bool value: " msg;
          ! panic msg
        end
      | Int(_) -> ! expect-bool-panic
      | Thunk(_) -> ! expect-bool-panic
      end
    | Int(i1) ->
      match v2
      | Bool(_) -> ! expect-int-panic
      | Int(i2) ->
        do eq? <- ! int_eq i1 i2;
        match eq?
        | True() -> ! correct
        | False() ->
          do i1 <- ! int_to_str i1;
          do i2 <- ! int_to_str i2;
          do msg <- ! str_append i1 " != ";
          do msg <- ! str_append msg i2;
          do msg <- ! str_append "wrong int value: " msg;
          ! panic msg
        end
      | Thunk(_) -> ! expect-int-panic
      end
    | Thunk(_) -> ! panic "thunks are not comparable"
    end
  end

  def fn report (e: Exception) : OS =
    match e
    | ParseError(loc, msg) ->
      do loc <- ! int_to_str loc;
      do loc <- ! str_append loc ": ";
      do msg <- ! str_append loc msg;
      ! panic msg
    | FreeVariable() -> ! panic "free variable"
    | TypeError() -> ! panic "type error"
    end
  end
end

def fn nil-env : EnvO =
  ! envo Empty()
end

def fn cbpv-env : EnvO =
  let fn app-int (f: U (Int -> Compu)) : Compu =
    comatch
    | .app() -> fn v ->
      match v
      | Bool(_) -> ! malg-err .failA() TypeError()
      | Thunk(_) -> ! malg-err .failA() TypeError()
      | Int(i) -> ! f i
      end
    | .bind() -> fn _ _ _ ->
      ! malg-err .failA() TypeError()
    | .os() ->
      ! mexn-err .fail() @(Value) TypeError()
    end
  in
  let fn int-op (op: U (Int -> Int -> Ret Value)) : Compu =
    do ! app-int; fn i1 ->
    do ! app-int; fn i2 ->
    do v <- ! op i1 i2;
    comatch
    | .app() -> fn _ -> ! malg-err .failA() TypeError()
    | .bind() -> fn _ _ k ->
      do ! malg .bindA() @(Value) { ! mexn .return() @(Value) v }; fn v ->
      ! k v
    | .os() -> ! mexn .return() @(Value) v
    end
  in
  ! envo Extend("add", Thunk({
    do ! int-op; fn i1 i2 ->
    do i <- ! add i1 i2;
    ret Int(i)
  }), Extend("mul", Thunk({
    do ! int-op; fn i1 i2 ->
    do i <- ! mul i1 i2;
    ret Int(i)
  }), Extend("eq", Thunk({
    do ! int-op; fn i1 i2 ->
    do b <- ! int_eq i1 i2;
    ret Bool(b)
  }), Empty())))
end

def fn demo-scompu (env: U EnvO) (term: SCompu) (ans: Value) (k: U OS): OS =
  ! interp env .compu() term .os() .run() { fn v ->
    ! value-eq v ans k
  } report
end

def fn demo (env: U EnvO) (src: String) (ans: Value) (k: U OS): OS =
  ! p_main src .run() { fn term ->
    ! demo-scompu env term ans k
  } report
end

main
  // if clause
  // do ! demo nil-env "(if true (ret true) (ret false))" Bool(True());

  // 4 envs: first with a bind stack, second with x in env, third with an app stack, and last with only variables in env
  // do ! demo nil-env "(bind (env (ret true)) x (env ((env (fn b (if b (env (ret x)) (ret false)))) true)))" Bool(True());

  // lambda in thunk
  // do ! demo nil-env "(bind (ret {(fn x (if x (ret false) (ret true)))}) not (bind (env (ret false)) x (! not x)))" Bool(True());

  // bind to lambda should fail
  // do ! demo nil-env "(bind (fn x (ret x)) f (ret true))" Bool(True());

  // apply to ret should fail
  // do ! demo nil-env "((ret true) true)" Bool(True());

  // call a bool should fail
  // do ! demo nil-env "! true" Bool(True());

  // test `! add 1 2`
  // do ! demo-scompu cbpv-env App(App(Force(Var("add")), Int(1)), Int(2)) Int(3);

  // test `! mul 3 2`
  // do ! demo-scompu cbpv-env App(App(Force(Var("mul")), Int(3)), Int(2)) Int(6);

  // test infinite loop
  // do ! demo-scompu cbpv-env Rec("loop", Force(Var("loop"))) Int(1);

  // test `do x <- ! add 2 3; ! add 1 x`
  // do ! demo-scompu cbpv-env Bind(
  //   App(App(Force(Var("add")), Int(2)), Int(3)),
  //   "x",
  //   App(App(Force(Var("add")), Int(1)), Var("x"))
  // ) Int(6);

  // factorial, poor usage of stack
  // do ! demo-scompu cbpv-env App(Rec("fact", Env(Lam("x",
  //   Bind(
  //     App(App(Force(Var("eq")), Var("x")), Int(0)),
  //     "b",
  //     If(Var("b"), Ret(Int(1)), Bind(
  //       App(App(Force(Var("add")), Var("x")), Int(-1)),
  //       "y",
  //       Bind(
  //         App(Force(Var("fact")), Var("y")),
  //         "z",
  //         App(App(Force(Var("mul")), Var("x")), Var("z"))
  //       )
  //     ))
  //   )
  // ))), Int(6)) Int(720);

  // factorial, tail call
  // do ! demo-scompu cbpv-env App(App(Rec("fact", Env(Lam("acc", Lam("x",
  //   Bind(
  //     App(App(Force(Var("eq")), Var("x")), Int(0)),
  //     "b",
  //     If(Var("b"), Ret(Var("acc")), Bind(
  //       App(App(Force(Var("add")), Var("x")), Int(-1)),
  //       "y",
  //       Bind(
  //         App(App(Force(Var("mul")), Var("x")), Var("acc")),
  //         "acc",
  //         App(App(Force(Var("fact")), Var("acc")), Var("y")),
  //       )
  //     ))
  //   )
  // )))), Int(1)), Int(6)) Int(720);
  ! exit 0
end
